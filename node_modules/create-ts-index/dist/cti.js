#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const fs = require("fs");
const path = require("path");
const yargs = require("yargs");
const TypeScritIndexWriter_1 = require("./TypeScritIndexWriter");
const version = (() => {
    if (fs.existsSync(path.join(__dirname, 'package.json'))) {
        const packageJSON = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json')).toString());
        return packageJSON.version;
    }
    if (fs.existsSync(path.join('.', 'package.json'))) {
        const packageJSON = JSON.parse(fs.readFileSync(path.join('.', 'package.json')).toString());
        return packageJSON.version;
    }
    return '1.0.14';
})();
function yargOptionBuilder(args) {
    return args
        .option('filefirst', {
        alias: 'f',
        default: false,
        describe: 'export list create filefirst, no option false, option true',
        type: 'boolean',
    })
        .option('addnewline', {
        alias: 'n',
        default: true,
        describe: 'deside add newline file ending. no option true, option false',
        type: 'boolean',
    })
        .option('usesemicolon', {
        alias: 's',
        default: true,
        describe: 'deside use semicolon line ending. no option true, option false',
        type: 'boolean',
    })
        .option('includecwd', {
        alias: 'c',
        default: true,
        describe: 'deside include cwd directory in task. no option true, option false',
        type: 'boolean',
    })
        .option('usetimestamp', {
        alias: 't',
        default: false,
        describe: `deside use timestamp(YYYY-MM-DD HH:mm) top line comment.
no option false, option true`,
        type: 'boolean',
    })
        .option('excludes', {
        alias: 'e',
        array: true,
        default: ['@types', 'typings', '__test__', '__tests__', 'node_modules'],
        describe: `pass exclude directory. default exclude directory is
['@types', 'typings', '__test__', '__tests__']`,
        type: 'string',
    })
        .option('fileexcludes', {
        alias: 'i',
        array: true,
        default: [],
        describe: 'pass exclude pattern of filename. default exclude directory is "[]"',
        type: 'string',
    })
        .option('targetexts', {
        alias: 'x',
        array: true,
        default: ['ts', 'tsx'],
        describe: `pass include extname. default extname is ["ts", "tsx"]. extname
pass without dot charactor.`,
        type: 'string',
    })
        .option('verbose', {
        alias: 'v',
        default: false,
        describe: 'verbose logging message. to option false, option true',
        type: 'boolean',
    })
        .option('quote', {
        alias: 'q',
        default: "'",
        describe: "deside quote character. default quote character is '",
        type: 'string',
    });
}
function ctiOptionBuilder(args, cwd) {
    const options = {
        addNewline: args.addnewline,
        excludes: args.excludes,
        fileExcludePatterns: args.fileexcludes,
        fileFirst: args.filefirst,
        globOptions: {
            cwd,
        },
        includeCWD: args.includecwd,
        quote: args.quote,
        targetExts: args.targetexts,
        useSemicolon: args.usesemicolon,
        useTimestamp: args.usetimestamp,
        verbose: args.verbose,
    };
    return options;
}
yargs
    .command('create <cwd>', 'create index.ts file in working directory', (args) => yargOptionBuilder(args), (args) => {
    const cwd = args['cwd'];
    if (!cwd) {
        console.log(chalk.default.magenta('Enter working directory, '));
        console.log(chalk.default.red('cti [working directory]'));
        process.exit(1);
    }
    (() => __awaiter(this, void 0, void 0, function* () {
        const cti = new TypeScritIndexWriter_1.TypeScritIndexWriter();
        const options = ctiOptionBuilder(args, cwd);
        console.log(chalk.default.yellowBright('Option: '), options);
        yield cti.create(options);
    }))();
})
    .command('entrypoint <cwd>', 'create entrypoint.ts file in working directory', (args) => yargOptionBuilder(args), (args) => {
    const cwd = args['cwd'];
    if (!cwd) {
        console.log(chalk.default.magenta('Enter working directory, '));
        console.log(chalk.default.red('cti [working directory]'));
        process.exit(1);
    }
    (() => __awaiter(this, void 0, void 0, function* () {
        const cti = new TypeScritIndexWriter_1.TypeScritIndexWriter();
        const options = ctiOptionBuilder(args, cwd);
        console.log(chalk.default.yellowBright('Option: '), options);
        yield cti.createEntrypoint(options);
    }))();
})
    .command('clean [cwd]', 'clean index.ts or entrypoint.ts file in working directory', (args) => yargOptionBuilder(args), (args) => {
    const cwd = args['cwd'];
    if (!cwd) {
        console.log(chalk.default.magenta('Enter working directory, '));
        console.log(chalk.default.red('cti [working directory]'));
        process.exit(1);
    }
    (() => __awaiter(this, void 0, void 0, function* () {
        const cti = new TypeScritIndexWriter_1.TypeScritIndexWriter();
        const options = ctiOptionBuilder(args, cwd);
        yield cti.clean(options);
    }))();
})
    .version(version, 'version', 'display version information')
    .help();
// tslint:disable-next-line
yargs.argv;
//# sourceMappingURL=cti.js.map